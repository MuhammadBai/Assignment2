# Assignment2 : Shell Scripting

## Overview
In this assignment, i have developed two shell scripting projects which automates system setup tasks and user managment on an Arch Linux environment. The scripts follows the best practices, focusing on error handling, documentation, and utilizing 'getopts' for command=line options.

---
# Project 1 - Packages installation setup

This project automates the system setup process on Arch Linux, helping to quickly set up your environment by installing key software packages and organizing configuration files.

## Overview of Scripts

### packages_list 1st script

  ```
  !bin/bash

  This script will create a list of packages in pkgs.txt

  packages=("kakoune" "tmux")

  Write each package to pkgs.txt
  echo "Creating pkgs.txt with the following packages:"
  for package in "${packages[@]}"; do
      echo "$package" >> pkgs.txt
      echo "-$package"
  done

  echo "Package list saved to pkgs.txt file"
```

### Purpose:
This script creates a `pkgs.txt` file that lists the software packages you want to install, such as `kakoune` and `tmux`.

### What It Does:
* Defines an array called `packages` that contains the software names.
* Loops through each package and writes its name to the `pkgs.txt` file.
* Displays the package names on the screen for you to verify.

### How to Use:
To generate your `pkgs.txt` file:

### Steps:
`chmod +x ./packages_list  # Make the script executable first`
`sudo ./packages_list      # Run the script to create pkgs.txt`

### PKGS 2nd script
This Scrpt will install packages listed in pkgs.txt file.

### 1. Ensure script is run as root.
```
if [[ $EUID -ne 0 ]]; then
    echo "Please run this script as root."
    exit 1
fi
```
* This code ensures that the script is executed with root privileges.
*  The EUID (Effective User ID) variable is checked. If it's not equal to 0, the script outputs a message asking the user to run the script as root and then exits. The 0 ID corresponds to the root user in Unix-based systems, which is required for installing software and making system changes.

### 2. Check if pkgs.txt exists
```
if [[ ! -f pkgs.txt ]]; then
    echo "Error: pkgs.txt not found."
    exit 1
fi
```
This part checks if the pkgs.txt file exists in the same directory as the script.
The -f test checks for the existence of the file. If the file doesn't exist, an error message is printed, and the script exits with status 1 which tells error.

### 3. Read pkgs.txt and install each package
```
while IFS= read -r package; do
    if [[ -n "$package" ]]; then  # Skip empty lines
        echo "Installing $package..."
        pacman -S --noconfirm "$package" || echo "Failed to install $package"
    fi
done < pkgs.txt        
```
* This block reads each line from the `pkgs.txt` file and installs the listed packages using the `pacman` package manager.
* `while IFS= read -r package`: This loop reads each line from pkgs.txt and stores it in the package variable. The IFS= (Internal Field Separator) ensures that leading/trailing spaces are not trimmed.
* `if [[ -n "$package" ]]`: This condition ensures that the line is not empty before attempting to install a package.
* `pacman -S --noconfirm "$package`": This command uses pacman to install the package. The `--noconfirm` flag automatically confirms any prompts like installation and dependencies.
* `|| echo "Failed to install $package`": If the installation fails for any reason, an error message is printed, indicating the failed package.

### Summary:
* The script first checks if it's running as root, which is required to install software.
* It then verifies that the `pkgs.txt` file is available, which contains the names of the packages to install.
* Finally, the script reads each package from `pkgs.txt`, and for each package, it attempts to install it using `pacman`. If an installation fails, it reports the error, but the script continues to process the remaining packages.

### Next Steps: 
1. make the script executable with `chmod +x PKGS`
2. `sudo ./PKGS`
3.  After running it, this will read the `packages_list` script to install the packages it see in the `pkgs.txt` file.
* **Dependencies**: It requires `pkgs.txt` to be in the same directory.

## `pkgs.txt` 3rd text file
A text file lists the packages to install which is used by PKGS script.
*  It provides a lsit of package names for installation.
*  Each package name is listed on a new line.
* **Example**: 
```
kakoune
tmux
```
* **It Uses**: 
    * `pkgs.txt` is generated by `packages_list` scrfipt, and the `PKGS` script uses this file to know which packages to install.
    *  you can see the two packages kakoune and tmux in pkgs.txt file after running `packages_list` script.

## `symlink`: 4th Script
    This script creates shortcuts (called "symbolic links") for your configuration files. These shortcuts let you easily access the files from standard locations on your system like `~/bin` or `~/.config`.

### What It Does:
- Creates the necessary directories (like `~/bin` and `~/.config/kak`) if they don’t already exist.
- Sets up symbolic links for various configuration files, such as Kakoune, Tmux, and `.bashrc`.
- After the links are created, it prints Symbolic links for configuration files have been successfully set up.

### How It Works:

### 1. Shebang specifies the script interpreter
```
#!/bin/bash
```
* This line specifies that the script should be interpreted by the bash shell. It's necessary for the script to know which interpreter to use when executed.

### 2. Symlinks() function
```
symlinks() {
}
```
* The function symlinks contains all the operations related to setting up symbolic links. By defining the function, you can call it later in the script to execute the commands that follow.

### 3. Define configuration files directory
```
    CONFIG_PATH="./configs"
```
* This variable holds the path to the directory where the configuration files are stored. In this case, the directory is ./configs (relative to where the script is executed).

### 4. Create ~/bin Directory and link scripts
```
    mkdir -p ~/bin
    ln -sf "$CONFIG_PATH/bin/sayhi" ~/bin/sayhi
    ln -sf "$CONFIG_PATH/bin/install-fonts" ~/bin/install-fonts
```
* This section handles linking executable scripts into the user's `~/bin` directory.
* `mkdir -p ~/bin`: Creates the ~/bin directory if it doesn’t already exist (`-p` ensures no error is thrown if the directory already exists).
* ln -sf "$CONFIG_PATH/bin/sayhi" ~/bin/sayhi: Creates a symbolic link from `./configs/bin/sayhi to ~/bin/sayhi`. The `-sf` flag forces the creation of the link, replacing any existing file or link with the same name.
* Similarly, `ln -sf "$CONFIG_PATH/bin/install-fonts" ~/bin/install-fonts` creates a symbolic link for the `install-fonts` script.

### 5. Kakoune and Tmux Configuration Links in ~/.config
```
    mkdir -p ~/.config/kak
    ln -sf "$CONFIG_PATH/config/kak/kakrc" ~/.config/kak/kakrc
    mkdir -p ~/.config/tmux
    ln -sf "$CONFIG_PATH/config/tmux/tmux.conf" ~/.config/tmux/tmux.conf
```
This part creates symbolic links for Kakoune and Tmux configuration files in the appropriate directories inside `~/.config`.
`mkdir -p ~/.config/kak`: Creates the directory ~/.config/kak if it doesn't exist.
`ln -sf "$CONFIG_PATH/config/kak/kakrc" ~/.config/kak/kakrc`: Creates a symbolic link from the custom Kakoune configuration `(./configs/config/kak/kakrc)` to `~/.config/kak/kakrc`, allowing Kakoune to use the custom configuration.
The same process is repeated for Tmux with its configuration file.

### 6. Link the Custom Bashrc to ~/.bashrc

```
    ln -sf "$CONFIG_PATH/home/bashrc" ~/.bashrc
```
This line creates a symbolic link for the custom Bash configuration file.
* The `ln -sf "$CONFIG_PATH/home/bashrc" ~/.bashrc` command creates a symbolic link from the custom Bash configuration (`./configs/home/bashrc)` to `~/.bashrc`, which is the default configuration file for Bash shells. This ensures that the custom configuration is used when the user opens a new shell session.

### 7. Prints the message
```
    echo "Symbolic links for configuration files have been successfully set up."
```
* After setting up all the symbolic links, this message is displayed to inform the user that the process has completed successfully.

### 8. Call the function to create Symbolic links

```
symlinks
```
* This line calls the symlinks function, executing all the commands defined within it. When the script is run, this function will be invoked, and the symbolic links will be created.

Summary:
* The script defines a function that automates the process of creating symbolic links for configuration files. These links are placed in standard directories like `~/bin` for executables and `~/.config` for application configurations.
* The script makes sure that the necessary directories exist before creating the symbolic links.
* The function is then called to execute all the link creation commands, and a confirmation message is printed once all links are set up successfully.

### Next Steps:
    1. make it executalbe by `chmod_x symlink`
    2. `sudo ./symlink will tell you weather the symbolic links are created or not.

## setup 5'th script

### Purpose:
This script takes care of the whole system setup by running the other scripts.

### What It Does:
* First, it runs the `PKGS` script to install all the necessary packages.
* Next, it runs the `symlink` script to create all the symbolic links for configuration files.
* Finally, it shows a message to let you know that the setup is complete.

### How It Works:

```
!/bin/bash

echo "Starting system setup..."

Run package installation
./PKGS

Run symlink file
./symlink

echo "System setup complete."
```
### What it does: 
  * Runs the `PKGS` script to install packages. 
  * This runs the `symlink` script to set up config file links.
  * Prints a message when setup is complete.

### Summary:
    This is the main script you’ll use to set up everything. It first installs the packages by running the `PKGS` script, then sets up the necessary links by running the `symlink` script.

* **How to use**:
        1. make the script executable `chmod +x setup`
        2. install the packages by running `sudo ./setup`

## Recap steps for installation:

### Setup Instructions
Run `packages_list` to create `pkgs.txt` with the packages you want to install:
    `sudo ./packages_list`

### Run Setup
Run `setup` to install the packages and set up links for the configuration files:
    `sudo ./setup`

**you can edit `pkgs.txt` to add any additional package you need.**

---

# Project 2: Creating a User

## User Creation Script

This Bash script automates the process of creating a new user on your system with specified options. It includes options to set the user's shell, add the user to additional groups, and perform necessary setup steps. Below is a breakdown of each section of the script and its functionality.

## Overview

This script is intended for system administrators or anyone needing to quickly add new users to a Linux system. It checks if the script is run as root, parses command-line options for customization, and creates a user with specified settings. To ensure security and organization, it also sets up a default home directory and files for the new user.

### Prerequisites
- **Root privileges**: This script must be run as root to have permission to create new users.
- **Arch Linux environment**: This script assumes Arch Linux commands. 

---

## How to Use

To run the script, use the following command:

```
sudo ./user_creation_script -u <username> [-s <shell>] [-g <additional_groups>]
```

### Options
* -u: Specifies the username for the new user (required).
* -s: Sets the user's login shell (optional).
* -g: Adds the user to additional groups (optional, comma-separated, no spaces).

Example command:

`sudo ./user_creation_script -u sam -s /bin/bash -g wheel,users`

# Breaking the script for explaination:

### 1. Shebang

`#!/bin/bash`

The `#!/bin/bash` line specifies that this script should be run in the Bash shell.

### 2. Root Check Function (root_check)
```
root_check() {
    if [[ $EUID -ne 0 ]]; then
        echo "Error: This script must be run as root."
        exit 1
    fi
}
```
The `root_check` function checks if the script is being executed with root privileges. The `EUID` variable checks the effective user ID. If it’s not root (0), the script outputs an error message and exits.

### 3. Usage Function 
```
usage() {
    echo "Usage: $0 -u <username> [-s <shell>] [-g <additional_groups>]"
    echo "  -u   Specify the username for the new user (required)"
    echo "  -s   Specify the shell for the new user (optional, default: /bin/bash)"
    echo "  -g   Specify additional groups (optional, comma-separated, no spaces)"
}
```
The `usage` function displays usage information, helping users understand the command-line options. This function is called if an incorrect option is entered.

### 4. Initialize Default Values
```
username=""
shell="/bin/bash"  # Default shell
groups=""
```
Here, variables `username`, `shell`, and `groups` are initialized. If no shell or group options are provided, `shell` defaults to `/bin/bash`.

### 5. Parse Command-Line Options
```
while getopts "u:s:g:" opt; do
    case "$opt" in
        u) username="$OPTARG" ;;   # Set the username
        s) shell="$OPTARG" ;;      # Set the shell
        g) groups="$OPTARG" ;;     # Set additional groups
        *) show_usage              # Show usage on invalid option
           exit 1 ;;
    esac
done
```
This part of the script handles options entered in the command line using `getopts`. It looks for the `-u`, `-s`, and `-g` options, saving their values to specific variables. If an unrecognized option is used, the script will display a help message showing correct usage, then exit.

### 6. Check for Required Username
```
if [[ -z "$username" ]]; then
    echo "Error: Username is required."
    show_usage
    exit 1
fi
```
If the `username` variable is empty (not provided), an error message is displayed, and the script exits. This ensures that the username is always provided.

### 7. User Creation Function 
```
creates_user() {
    echo "Creating user '$username' with shell '$shell' and groups '$groups'..."
```
This section of the script processes command-line options using `getopts`. It looks for options `-u`, `-s`, and `-g`, storing their values in specific variables. If an option isn’t recognized, the script will show a usage guide and stop running.

### 8. Adding the User
```
    if useradd -m -s "$shell" -G "$groups" "$username"; then
        echo "User '$username' created successfully."
```
The `useradd` command creates a new user with the specified shell and groups. If the user is successfully created, a success message is displayed.

### 9. Password Prompt
```
        echo "Please enter a password for the new user:"
        passwd "$username"
```
This asks the user to set a password. The `passwd` command will be used to secure the account of the user.

### 10. Setting Up Home Directory
```
        cp -r /etc/skel/. "/home/$username"
        chown -R "$username":"$username" "/home/$username"
        echo "Home directory and default files set up for '$username'."
```
Files from `/etc/skel` which is called skeleton directory as a name tells skel are copied to the new user’s home directory to provide default files, such as `.bashrc`. Ownership of the files is then updated to match the new user.

### 11. Error Handling
```
    else
        echo "Error: Failed to create user '$username'."
        exit 1
    fi
}
```
If `useradd` fails, an error message is displayed, and the script exits.

## To execute it:
```
root_check
creates_user
```
Finally, `root_check` is called to ensure the script is run as root, followed by `creates_user` to create the user with the specified settings.

## Example Usage
To create a new user named johndoe with a custom shell and additional groups, use:
```
sudo ./user_creation_script -u Sam -s /bin/bash -g wheel,users
```
This command will:

1. Create the user `Sam`.
2. Set the shell to `/bin/bash`.
3. Add the user to `wheel` and `users` groups.

### *Important*
* **Root Access**: Running this script without root access will produce an error and exit.

## Why Use the `wheel` and `users` Groups?

In many Linux systems, you'll encounter predefined groups like `wheel` and `users`. These groups are commonly used to manage user permissions and system access, but you are free to use any groups that suit your needs. Here's a quick overview of what these groups typically do and why you might use them:

### 1. **`wheel` Group**:
   -  The `wheel` group is often used to give users administrative privileges. Users in the `wheel` group are usually allowed to execute commands with `sudo`, which gives them elevated permissions to perform tasks that require admin rights (like installing software or changing system settings).
   - **Why It's Used**: If you want to allow a user to perform administrative tasks, adding them to the `wheel` group is a common approach. However, you could choose any other group that you’ve set up for admin tasks, or you might decide not to give the user administrative access at all.
   -  You can replace `wheel` with any group name that fits your specific needs, or leave it out if the user doesn’t need elevated access.

### 2. **`users` Group**:
   -  The `users` group is a default group for regular, non-administrative users. It's typically used to assign common permissions to all users in the system.
   - **Why It's Used**: If you want to organize users under a common group for general tasks, the `users` group is a good choice. It's not strictly necessary, and you could use a different group name or even leave it out if you prefer.
   -  Similar to the `wheel` group, you can replace `users` with any other group that suits your system structure. For example, you might use a group like `staff`, `devs`, or `clients` depending on what kind of access you want users to have.

### Can You Use Any Group?

Yes, you can absolutely use any group that already exists on your system, or you can create new groups to suit your needs. For instance, if you want to add a user to a group like `staff` or `devs`, you can do that without any issues.

**Example**:
If you wanted to add the user to a `developers` group instead of `wheel` or `users`, the script would look like this:
```
sudo ./user_creation_script -u Sam -s /bin/bash -g developers
```
