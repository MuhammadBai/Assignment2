# Assignment2 : Shell Scripting

## Overview
In this assignment, i have developed two shell scripting projects which automates system setup tasks and user managment on an Arch Linux environment. The scripts follows the best practices, focusing on error handling, documentation, and utilizing 'getopts' for command=line options.

---

## Project 1: System Setup Scripts

### Purpose
This project automates the installation of essential software packages and creates symbolic links to configuration files stored in a remote Git repository. It speeds uo the sustem setup process, making it fast and repeatable.

## 1.`packages_list`
 This script generates a list of software packages that will be installed during setup which are kakoune and tmux.
 
 * **Purpose**: This automates the creation of a list (`pkgs.txt`) which contains names of software packages to install.
 * **Function**: This adds each specified package to `pkgs.txt` and prints the package name on the console for confirmation.
 * **Its Uses**: 
          1. make the script excutable with `chmod +x packages_list`   
          2. show you if it works by the command `sudo ./packages_list`
          3. this will generate the list of kakoune and tmux in the `pkgs.txt` file. 
 * It creates a lists of packages inside pkgs.txt file.

 ## 2.`PKGS`
This script installs all packages in pkgs.txt using the pacman package manager.

* **Purpose**: It makes the installation of multiple packagess simple by reading it from `pkgs.txt` file.
* **Function**: 
    * It checks if the script is run as root which is necessary for package installation.
    * It verifies the existence of pkgs.txt and reads package names from it.
    * Then it installs each package, outputs each package name as it installs, and tells you if a package fails to install.
* **It Uses**: 
        1. make the script executable with `chmod +x PKGS`
        2.`sudo ./PKGS`
        3. After running it, this will read the `packages_list` script to install the packages it see in the `pkgs.txt` file.
* **Dependencies**: It requires `pkgs.txt` to be in the same directory.

## 3.`pkgs.txt`
A text file listing the packages to install which is used by PKGS script.
* **Purpose**: It provides a lsit of package names for installation.
* **Format**: Each package name is listed on a new line.
* **Example**: 
```
kakoune
tmux
```
* **It Uses**: 
    * `pkgs.txt` is generated by `packages_list` and read by `PKGS`.
    *  you can see the two packages kakoune and tmux after running `packages_list` script.

## 4.`symlink`:
    This script creates shortcuts (called "symbolic links") for your configuration files. These shortcuts let you easily access the files from standard locations on your system like `~/bin` or `~/.config`.

* **Purpose**: It organizes your configuration files so they are easy to access and in consistent place.
* **What it does**:
    * It creates the needed folder (like `~/bin` and `~/.config/kak`) if they are not ther yet.
    * It sets up links for specific config files like for kakoune, Tmux, and `.bashrc`.
    * It shows a confirmation message when the links are created.
* **How to Use**:
            1. make it executable by `chmod +x symlink`
            2. `sudo ./symlink` will tell you wether the symbolic links are created or not. 

## 5. `setup`:
This is the main script that runs the entire setup process.

* **Purpose**: 
    This is the main setup that runs the entire process.
* **What it does**:
    * Shows a message that setup is installing.
    * Runs the `PKGS` script to install packages.
    * This runs the `symlink` script to set up config file links.
    * Prints a message when setup is complete.
* **How to use**:
        1. make the script executable `chmod +x setup`
        2. install the packages by running `sudo ./setup`

# Setup Instructions
Run `packages_list` to create `pkgs.txt` with the packages you want to install:
    `./packages_list`

# Run Setup
Run `setup` to install the packages and set up links for the configuration files:
    `sudo ./setup`


# Requirements:
    * Arch linux Operating System.
    * To run `PKGS` and `setup` (for installing packages) you need root access.
    * `pacman` package manager should be installed and setup.


**you can edit `pkgs.txt` to add any additional package you need.**

---

# Project 2: Creating a User

# User Creation Script

This Bash script automates the process of creating a new user on your system with specified options. It includes options to set the user's shell, add the user to additional groups, and perform necessary setup steps. Below is a breakdown of each section of the script and its functionality.

## Overview

This script is intended for system administrators or anyone needing to quickly add new users to a Linux system. It checks if the script is run as root, parses command-line options for customization, and creates a user with specified settings. To ensure security and organization, it also sets up a default home directory and files for the new user.

### Prerequisites
- **Root privileges**: This script must be run as root to have permission to create new users.
- **Arch Linux environment**: This script assumes Arch Linux commands. 

---

## How to Use

To run the script, use the following command:

```
sudo ./user_creation_script -u <username> [-s <shell>] [-g <additional_groups>]
```

# **Options**
    * -u: Specifies the username for the new user (required).
    * -s: Sets the user's login shell (optional, default: /bin/bash).
    * -g: Adds the user to additional groups (optional, comma-separated, no spaces).

Example command:

`sudo ./user_creation_script -u sam -s /bin/bash -g wheel,users`

# Breaking the script for explaination:

## Shebang

`#!/bin/bash`

The `#!/bin/bash` line specifies that this script should be run in the Bash shell.

## Root Check Function (root_check)
```
root_check() {
    if [[ $EUID -ne 0 ]]; then
        echo "Error: This script must be run as root."
        exit 1
    fi
}
```
The `root_check` function checks if the script is being executed with root privileges. The `EUID` variable checks the effective user ID. If it’s not root (0), the script outputs an error message and exits.

## Usage Function 
```
usage() {
    echo "Usage: $0 -u <username> [-s <shell>] [-g <additional_groups>]"
    echo "  -u   Specify the username for the new user (required)"
    echo "  -s   Specify the shell for the new user (optional, default: /bin/bash)"
    echo "  -g   Specify additional groups (optional, comma-separated, no spaces)"
}
```
The `usage` function displays usage information, helping users understand the command-line options. This function is called if an incorrect option is entered.

## Initialize Default Values
```
username=""
shell="/bin/bash"  # Default shell
groups=""
```
Here, variables `username`, `shell`, and `groups` are initialized. If no shell or group options are provided, `shell` defaults to `/bin/bash`.

## Parse Command-Line Options
```
while getopts "u:s:g:" opt; do
    case "$opt" in
        u) username="$OPTARG" ;;   # Set the username
        s) shell="$OPTARG" ;;      # Set the shell
        g) groups="$OPTARG" ;;     # Set additional groups
        *) show_usage              # Show usage on invalid option
           exit 1 ;;
    esac
done
```
This part of the script handles options entered in the command line using `getopts`. It looks for the `-u`, `-s`, and `-g` options, saving their values to specific variables. If an unrecognized option is used, the script will display a help message showing correct usage, then exit.

## Check for Required Username
```
if [[ -z "$username" ]]; then
    echo "Error: Username is required."
    show_usage
    exit 1
fi
```
If the `username` variable is empty (not provided), an error message is displayed, and the script exits. This ensures that the username is always provided.

## User Creation Function 
```
creates_user() {
    echo "Creating user '$username' with shell '$shell' and groups '$groups'..."
```
This section of the script processes command-line options using `getopts`. It looks for options `-u`, `-s`, and `-g`, storing their values in specific variables. If an option isn’t recognized, the script will show a usage guide and stop running.

### Adding the User
```
    if useradd -m -s "$shell" -G "$groups" "$username"; then
        echo "User '$username' created successfully."
```
The `useradd` command creates a new user with the specified shell and groups. If the user is successfully created, a success message is displayed.

### Password Prompt
```
        echo "Please enter a password for the new user:"
        passwd "$username"
```
This asks the user to set a password. The `passwd` command will be used to secure the account of the user.

### Setting Up Home Directory
```
        cp -r /etc/skel/. "/home/$username"
        chown -R "$username":"$username" "/home/$username"
        echo "Home directory and default files set up for '$username'."
```
Files from `/etc/skel` which is called skeleton directory as a name tells skel are copied to the new user’s home directory to provide default files, such as `.bashrc`. Ownership of the files is then updated to match the new user.

### Error Handling
```
    else
        echo "Error: Failed to create user '$username'."
        exit 1
    fi
}
```
If `useradd` fails, an error message is displayed, and the script exits.

## Main Script Execution
```
root_check
creates_user
```
Finally, `root_check` is called to ensure the script is run as root, followed by `creates_user` to create the user with the specified settings.

## Example Usage
To create a new user named johndoe with a custom shell and additional groups, use:
```
sudo ./user_creation_script -u Sam -s /bin/bash -g wheel,users
```
This command will:

1. Create the user `Sam`.
2. Set the shell to `/bin/bash`.
3. Add the user to `wheel` and `users` groups.

### *Important*
* **Root Access**: Running this script without root access will produce an error and exit.

## Why Use the `wheel` and `users` Groups?

In many Linux systems, you'll encounter predefined groups like `wheel` and `users`. These groups are commonly used to manage user permissions and system access, but you are free to use any groups that suit your needs. Here's a quick overview of what these groups typically do and why you might use them:

### 1. **`wheel` Group**:
   - **Purpose**: The `wheel` group is often used to give users administrative privileges. Users in the `wheel` group are usually allowed to execute commands with `sudo`, which gives them elevated permissions to perform tasks that require admin rights (like installing software or changing system settings).
   - **Why It's Used**: If you want to allow a user to perform administrative tasks, adding them to the `wheel` group is a common approach. However, you could choose any other group that you’ve set up for admin tasks, or you might decide not to give the user administrative access at all.
   - **Customization**: You can replace `wheel` with any group name that fits your specific needs, or leave it out if the user doesn’t need elevated access.

### 2. **`users` Group**:
   - **Purpose**: The `users` group is a default group for regular, non-administrative users. It's typically used to assign common permissions to all users in the system.
   - **Why It's Used**: If you want to organize users under a common group for general tasks, the `users` group is a good choice. It's not strictly necessary, and you could use a different group name or even leave it out if you prefer.
   - **Customization**: Similar to the `wheel` group, you can replace `users` with any other group that suits your system structure. For example, you might use a group like `staff`, `devs`, or `clients` depending on what kind of access you want users to have.

### Can You Use Any Group?

Yes, you can absolutely use any group that already exists on your system, or you can create new groups to suit your needs. For instance, if you want to add a user to a group like `staff` or `devs`, you can do that without any issues.

**Example**:
If you wanted to add the user to a `developers` group instead of `wheel` or `users`, the script would look like this:
```
sudo ./user_creation_script -u Sam -s /bin/bash -g developers
```
